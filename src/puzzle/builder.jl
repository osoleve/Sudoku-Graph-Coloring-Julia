include("../structure/graph.jl")
include("io.jl")
include("solver.jl")
include("vpt.jl")

"""
    random_puzzle(psize::Int=3, hints::Int=0)::SudokuGraph

Given a puzzle size and the number of hints to supply, return a random
valid sudoku puzzle in the form of a graph.
"""
function random_puzzle(psize::Int=3, hints::Int=0)::SudokuGraph
    if hints == 0
        hints = psize^4 - psize^3
    end

    if psize == 1
        throw("There is no size-1 Sudoku")
    else
        # Create a new puzzle by first constructing
        # the trivial sudoku and deriving a new puzzle from it.
        graph = trivial_sudoku(psize)
        graph = derive_new_puzzle!(graph, 500)
    end

    to_remove = psize^4 - hints

    # Remove nodes symmetrically in pairs because it's prettier that way
    for i in 1:2:to_remove
        node = rand(get_nonblank_nodes(graph))
        coords = node.coordinates
        # Get the opposite node symmetrically to also remove
        nodes = [node, get_node(coords[end:-1:1], graph)]
        unset_value!.(nodes, fill(graph))
    end
    return graph
end

"""
    trivial_sudoku(psize::Int)::SudokuGraph

Returns the trivial sudoku for a given size.

The trivial sudoku is generated by the following algorithm:

Example puzzle size: 3
    values = [1,2,3,4,5,6,7,8,9]
    for band in puzzle
        for row in band
            assign values to row
            rotate values array by 3
        end
        rotate values array by 1
    end

Example Output:
    1 2 3 | 4 5 6 | 7 8 9
    4 5 6 | 7 8 9 | 1 2 3
    7 8 9 | 1 2 3 | 4 5 6
    -------------------
    2 3 4 | 5 6 7 | 8 9 1
    5 6 7 | 8 9 1 | 2 3 4
    8 9 1 | 2 3 4 | 5 6 7
    -------------------
    3 4 5 | 6 7 8 | 9 1 2
    6 7 8 | 9 1 2 | 3 4 5
    9 1 2 | 3 4 5 | 6 7 8
"""
function trivial_sudoku(psize::Int)::SudokuGraph
    graph = SudokuGraph(psize)

    vals = []
    row_of_values = collect(1:psize^2)

    for i in 1:psize
        for j in 1:psize
            append!(vals, row_of_values)
            row_of_values = circshift(row_of_values, -psize)
        end
        row_of_values = circshift(row_of_values, -1)
    end

    for (node, value) in zip(graph.nodes, vals)
        set_value!(node, value)
    end

    # rotate and mirror to make it print right
    return mirror!(rotate!(graph), Vertical)
end

"""
    derive_new_puzzle!(graph::SudokuGraph, steps::Int=50)

Applies a sequence of validity-preserving transformations
in order to create a different valid sudoku given a valid sudoku.
"""
function derive_new_puzzle!(graph::SudokuGraph, steps::Int=50)
    for _ in 1:steps
        random_transformation!(graph)
    end

    return graph
end

"""
    new_puzzle(psize::Int, hints::Int)

Directly print a random puzzle to STDOUT.
For arguments see random_puzzle()
"""
function new_puzzle(psize::Int=3, hints::Int=0)
    print(random_puzzle(psize, hints))
end # function
