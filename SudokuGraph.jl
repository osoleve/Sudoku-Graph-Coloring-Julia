include("SudokuNode.jl")
include("SudokuEdge.jl")

using Lazy: @>, @>>, @as
using Base.Iterators: product, flatten

mutable struct SudokuGraph
    nodes::Vector{SudokuNode}
    edges::Vector{Edge}

    puzzle_size::Int

    function SudokuGraph(puzzle_size::Int)
        #=
        The node coordinates are (row, column, cell),
        generated by creating the cartesian set of (row, col)
        and then assigning the cell based on a formula.
        =#

        nodes = @as x begin
            1:puzzle_size^2
            product(x, x)
            SudokuNode.(x)
            set_cell!.(x, puzzle_size)
            reshape(x, puzzle_size^4)
        end

        edges = nodes_to_edges(nodes)

        return new(nodes, edges, puzzle_size)
    end
end

function get_node(coordinates::Tuple{Int,Int}, graph::SudokuGraph)::SudokuNode
    return @>> graph.nodes begin
        filter(node -> node.coordinates == coordinates)
        pop!
    end
end

function get_cell(graph::SudokuGraph, i::Int)::Vector{SudokuNode}
    return @>> graph.nodes begin
        filter(node -> node.cell == i)
        collect
    end
end

function Base.print(graph::SudokuGraph)
    function format_value(value::Int, maxwidth::Int)::String
        padding = maxwidth - length(string(value))

        if value == 0
            value = " "
        else
            value = string(value)
        end

        return lpad(value, padding)
    end

    println()
    maxwidth = length(string(graph.puzzle_size^2))+1
    width = graph.puzzle_size^2
    for i in 1:width
        for j in 1:width
            @> begin
                get_node((i, j), graph)
                get_value
                format_value(maxwidth)
                string(j % graph.puzzle_size == 0 && j != width ? " |" : "")
                string(j == width ? "\n" : " ")
                print
            end
        end
        if i % graph.puzzle_size == 0 && i != width
            println(repeat('-', graph.puzzle_size + maxwidth * graph.puzzle_size^2 + (graph.puzzle_size % 2 == 0)))
        end
    end
    println()
end

function get_neighbors(node::SudokuNode, graph::SudokuGraph)::Vector{SudokuNode}
    return @>> graph.edges begin
        filter(edge -> node in edge)
        map(get_nodes)
        flatten
        collect
        filter(x -> !isequal(node, x))
    end
end

function get_saturated_values(node::SudokuNode, graph::SudokuGraph)::Vector{Int}
    return @>> graph begin
        get_neighbors(node)
        filter(x -> x.value > 0)
        map(get_value)
        unique
    end
end

function get_saturation(node::SudokuNode, graph::SudokuGraph)::Int
    return get_saturated_values(node, graph) |> length
end

function get_possible_values(node::SudokuNode, graph::SudokuGraph)::Vector{Int}
    sv = get_saturated_values(node, graph)
    return collect(filter(x -> x âˆ‰ sv, 1:graph.puzzle_size^2))
end

function set_possible_values!(node::SudokuNode, graph::SudokuGraph)::SudokuNode
    node.possible_values = get_possible_values(node, graph)
    return node
end

function unset_value!(node::SudokuNode, graph::SudokuGraph)::SudokuNode
    node.value = 0
    set_possible_values!(node, graph)
    return node
end

function get_blank_nodes(graph::SudokuGraph)::Vector{SudokuNode}
    return @>> begin
        graph.nodes
        filter(x -> get_value(x) == 0)
        collect
    end
end

function get_nonblank_nodes(graph::SudokuGraph)::Vector{SudokuNode}
    return @>> begin
        graph.nodes
        filter(x -> get_value(x) != 0)
        collect
    end
end
